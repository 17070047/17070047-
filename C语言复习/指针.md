# 指针

+ [`指针`](#指针)
  + [`指针及其使用`](#指针及其使用)
    + [`初识指针`](#初识指针)
    + [`指针有什么用`](#指针有什么用)
    + [`指针运算`](#指针运算)
  + [`指向数组的指针`](#指向数组的指针)
    + [`指向一维数组的指针`](#指向一维数组的指针)
    + [`指向二维数组的指针`](#指向二维数组的指针)
  + [`指针数组`](#保存指针的数组)
  + [`数组指针`](#数组指针)
  + [`指针在函数中的应用`](#指针在函数中的应用)
    + [`指针作为函数参数`](#指针作为函数参数)
    + [`指针作为函数返回值`](#指针作为函数返回值)
    + [`指向函数的指针`](#指向函数的指针)
  + [`二级指针`](#二级指针)

## 指针

### 指针及其使用

#### 初识指针

指针是什么？

首先理解 " & " 和 " * " ( 取地址和指针运算符 )

```c
int  var1;
char var2[10];
//打印出地址
printf("var1 变量的地址： %p\n", &var1  );
printf("var2 变量的地址： %p\n", &var2  );
/*
var1 变量的地址： 0x7fff5cc109d4
var2 变量的地址： 0x7fff5cc109de
*/
```

```c
scanf("%d",&i);//传入一个地址
//scanf的函数原型
int scanf(const char * restrict format,...);
```

如何定义指针变量？

+ 指针本身是一个变量，它存储的是数据在内存中的地址而不是数据本身的值。它的定义如下:

```c
数据类型* 变量名  或  数据类型 *变量名 //只是*的位置不同而已

int *pointer;
char *name;
```

+ 这样就定义好了两个指针变量，int 和 char 表示该这两个指针变量指向的数据类型，*表示这是指针变量。

+ 指针变量的初始化：每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址,

![train13.png](https://upload-images.jianshu.io/upload_images/9140378-ccd065db4a4c4091.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)

```c
 int a = 10,*p;  
 p = &a
 int a = 10;
 int *p = &a;
```

+ 首先我们可以理解 int * 这个是要定义一个指针p，然后因为这个指针存储的是地址所以要对a取地址(&)将值赋给指针p，也就是说这个指针p指向a。
+ 可能会对对这两种定义方法感到迷惑，其实他俩的意思是一样的。第一种定义方法定义了int型的变量 a 和 指针 p ，然后将 a 的地址赋给 p
+ 第二种是在定义指针p的同时将 a 的地址赋给指针 p。我们姑且理解为" int * "是定义指针的标志。

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。NULL 指针是一个定义在标准库中的值为零的常量

```c
int  *ptr = NULL;
printf("ptr 的地址是 %p\n", ptr  );
return 0;
/*
结果：
ptr 的地址是 0x0
*/
```

#### 指针有什么用

这样我们就可以通过*p来找到指针所指向的变量a的地址，然后对地址中的值(值是10)进行操作。

```c
printf("%p",p)   //结果是一个地址(p指向的变量a的地址)。
printf("%d",*p)  //结果是10，变量a的值。
printf("%d",&p)  //结果是一个地址(指针p的地址，因为指针也是一个变量自己也有地址的)
```

题目：

使用指针交换两个整数变量的值，并写成函数形式，即实现void swap(int *a, int *b)函数

#### 指针运算

指针就是地址，地址在内存中也是以数的形式存在，所以指针也能做加法，减法，比较等运算

```c
int a = 5;
int *i = &a;
printf("%p\n",i);
i ++;
printf("%p\n",i);
i -= 2;
printf("%p\n",i);
return 0;
/*
000000000062FE44
000000000062FE48
000000000062FE40
*/
```

### 指向数组的指针

#### 指向一维数组的指针

为指针赋数组数据的地址

+ 数组的每个数据都保存在一个储存单元里面，只要是储存单元就会有地址，既然指针变量的储存单元可以保存地址，那么就可以用指针保存数组储存单元的地址

```c
int *p_i = NULL;   //定义指针变量
int num[5] = {1，2，3，4，5};
for(int i = 0;i < 5;i ++)
{
    p_i = &num[i];  //先让指针指向想要输出的数据
    printf("%d ",*p_i); //通过指针输出数组数据
}
```

使用数组名为指针赋值

+ 对于下面的数组和指针

```c
int num[5] = {1,2,3,4,5};
int *p_i;
```

+ 为指针赋予第一个数组数据的地址的方式为：

```c
p_i = &num[0];
```

+ 其实还可以写成下面的形式,直接将数组名赋予指针，指针需要储存的数据就是地址，而 num 就代表的是数组的首地址

```c
p_i = num;
```

指向数组的指针的加减运算,  -- 数组的另外一种遍历方式

![train14.png](https://upload-images.jianshu.io/upload_images/9140378-29428f6b9449104d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

+ 对于*(num + i), num 是数组的首地址，指向数组的首元素，而num + i 则便是数组的第 i 个元素的地址，再加上指针运算符* 就得到了该元素的值
+ array每次加一的时候，它自己的值都会增加sizeof(int)，加 i 的时候就增加i *sizeof ( int )

```c
int num[5] = {2,4,6,8,10};
for(int i = 0;i < 5;i ++)
{
    //通过数组下标遍历数组
    printf("%d",num[i]);
    //通过指针变量遍历数组
    printf("%d",*(num + i));
}
```

#### 指向二维数组的指针

跟一位数组同样的道理

```c
int num[3][2] = {{1,2},{3,4},{5,6}};
int *p_i = &num[0][0];
```

+ 不过在这里要注意的是，不能为指针直接赋予二维数组的数组名，即上面的代码不能写成: int *p_i = num;

<div align="center">

![train9.png](https://upload-images.jianshu.io/upload_images/9140378-261b27c28b07feab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

+ 假设定义一个二维数组：num[m][n];一个指针p指向了这个二维数组的首地址，那么对于数组的数据 num[i][j](0 <= i < m,0 <= j < n) ，指针变量p要想指向这个数据,那么指针变量 p = p + n * i + j;

```c
double arr[4][3] = {
    {78.4,72.1,41.2},
    {56.4,12.4,45.1},
    {12.5,14.6,20.4},
    {23.5,34.6,67.8}
}
double *p_d = &arr[0][0]; //指针变量的类型必须要跟数组类型一致
printf("二维数组中arr[3][2]位置上的数据为：%6.11f\n",*(p_d + 3 * 3 + 2));
```

### 保存指针的数组

<div align="center">

![train15.png](https://upload-images.jianshu.io/upload_images/9140378-f25fae78ce0cba15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

从名字的定义上来看，数组元素全为指针的数组就称为指针数组。

+ 一维指针数组的定义形式为： 类型名 *数组标识符[数组长度]
例如，一个一维指针数组的定义：

```c
int *ptr_array[10]
```

+ 因为[]比*的优先级高，所以也可以看成是*(ptr_array[10])，括号里面ptr_array[10]表示的是一个长度为10的数组，然后括号外面的* 说明数组的元素类型是 int* 的指针类型

+ 看一个指针数组的例子

```c
int main()
{
  int a = 16, b = 932, c = 100;
  //定义一个指针数组
  int *arr[3] = {&a, &b, &c};
  printf("%d %d %d\n", *arr[0], *arr[1], *arr[2]);
  return 0;
}
/*
16 932 100
*/

```

因为数组arr里面的元素都是指针，所以在声明指针数组的时候，把a,b,c的地址&啊，&b,&c传进去了，在输出的时候先通过 数组下标得到数组内的指针，即a,b,c的地址，然后，再通过 运算符 * 将数据取出

### 数组指针

定义方式

```c
datatype (*ptr)[length]
```

如果一个指针指向了数组，就称它为数组指针,例如：

```c
int a[4][3] = {{0,2,3},{1,5,6},{2,3,4},{7,8,9}};
```

在概念上他是像这种矩阵的样子：

```c
0 2 3
1 5 6
2 3 4
7 8 9
```

但实际上他在内存中是链式的：

```c
0 2 3 1 5 6 2 3 4 7 8 9
```

我们可以将这个二维数组分解成多个一维数组,a[0]包括a[0][0]、
a[0][1]、a[0][2] 三个元素

```c
     a[][0]  a[][1]  a[][2]
a[0]    0       2       3
a[1]    1       5       6
a[2]    2       3       4
a[3]    7       8       9
```

这里的 a 就是那四个一位数组的组名，接着我们定义一个 数组指针

```c
int (*p)[4] = a;
```

括号里面的*代表 p 是一个指针，[4] 代表这个 指针 p指向了类型为 int[4] 的数组

下面使用数组指针来遍历一遍二维数组

+ p指向数组a的开头，就是指向第0行元素，p + 1 代表的是数组中的第一行元素
+ 那么 *(p + 1) 就表示的是 数组a 的第一行元素，是多个数据
+ *(p + 1) + 1 则表示的是第一行的第一个数据的地址
+ ((p+1)+1)表示第一行的第一个数据的值

### 指针在函数中的应用

#### 指针作为函数参数

```c
#include "stdio.h"

void add_five(int *);
int main()
{
    int i = 10;
    add_five(&i);
}

void add_five(int *a)
{
    *a = *a + 5;
}
```

#### 指针作为函数返回值

#### 指向函数的指针

### 二级指针