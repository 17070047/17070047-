# 选择题

## 1. 如何根据先序中序求后序。

+ 1）先序序列最中间一个元素为根结点，将线性表分为两部分（即二叉树的左右子树），再用中序去分别处理两个部分(即判断左右)。2）对每个部分再执行1），直到剩余一个结点。
+ 1)中序序列第一个元素为根结点，将线性表分为两部分（即二叉树的左右子树），再用先序去分别处理两个部分(即判断左右)。2）对每个部分再执行1），直到剩余一个结点。
+ 1)先序序列第一个元素为根结点，将线性表分为两部分（即二叉树的左右子树），再用中序去分别处理两个部分(即判断左右)。2）对每个部分再执行1），直到剩余一个结点。(√)

## 2. 用深度优先遍历方法遍历一个有向无环图，并在深度优先遍历算法中按退栈次序打印出相应的顶点，则输出的顶点序列是（）。

`答案：` 逆拓扑排序

+ 其实树（无环图相当于树）深度优先遍历就是拓扑排序，“按退栈次序打印出相应的顶点”就是逆拓扑的。
+ DFS递归内部，输出代码写在内部DFS下一行，就是逆拓扑，写在DFS前面一行就是拓扑，不过拓扑一般都用BFS写的吧。。没用DFS写过

## 3.请问下面哪种方式可以在不改变原来数组的情况下，拷贝出数组 b ，且满足 b!=a 。例如数组 a 为 [1,2,3] 。

+ let b=a;
+ let b=a.slice();
+ let b=a.splice(0,0);
+ let b=a.concat();  (√)

## 4.把一棵树转换为二叉树后，这棵二叉树的形态是（）

+ 唯一的 (√)
+ 有多种
+ 有多种，根结点没有左孩子
+ 有多种，根结点没有右孩子

![image.png](https://upload-images.jianshu.io/upload_images/9140378-35ac0331c93981ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)

## 5.在下列几种排序方法中，空间复杂度最高的是（）

+ 归并排序 (√)
+ 快速排序
+ 插入排序
+ 选择排序

`解析：`

+ 归并排序空间复杂度为O（n）
+ 快速排序：
  + 就地快排空间复杂度为O（1） 
    + 使用递归：
      + 每一次都平分数组，即最优情况是O（logn）
      + 退化为冒泡排序，即最差情况是O（n）
+ 插入和选择都是O（1）

## 6.设顺序表的长度为 n 。下列排序方法中，最坏情况下比较次数小于 n(n-1)/2 的是（ ）

+ 堆排序 (√)
+ 快速排序
+ 简单插入排序
+ 冒泡排序

`解析：`堆排序最坏情况下比较次数为 O(nlog2n) ，快速排序、简单插入排序、冒泡排序最坏情况下比较次数为 n(n-1)/2

## 7. 在非空二叉树中，任一结点均有两颗二叉树，这种说法（）

`答案：` 错误

+ 二叉树是一棵树，其中每个节点至多有两个儿子。
+ 应该是任一节点至多有两颗二叉树。

## 8. 设某棵二叉树中只有度数为0和度数为2的结点且度数为0的结点数为n，则这棵二叉中共有（）个结点。

`答案：` 2n - 1

+ 二叉树中一个性质：`度为0的结点（叶子节点）个数n0等于度为2的结点个数n2加1`，即N2=N0-1。总结点数N=N0+N1+N2=N0+0+(No-1)=2N0-1。N1表示树中度为1的结点。
+ 度数只有0和2，说明这是一颗满二叉树，那么总节点数为2^(h+1) -1 h是高度，叶子节点数为2^h,则2^h=n ,2^(h+1) - 1=2n-1

## 9. 利用3,6,8,12这四个值作为叶子结点的权值，生成一棵赫夫曼树，该树的带权路径长度为( )。

`答案：` 55

![image](https://uploadfiles.nowcoder.com/images/20170731/7864514_1501510571600_69B05851F2FE58A175066F1E5DA68C38)

+ 3,6所在的位置路径长度为3；8在的位置路径长度为2；12在的位置路径长度为1.所以他们的带权路径长度等于（3+6）*3+（8*2）+（12*1）=55.这里需要注意的是都是最小的两个权值相加，然后能凑成一棵树为止。

## 10. 将一棵树t转换为孩子兄弟链表表示的二叉树h,则t的后序遍历是h的()

`答案：`中序遍历

+ `树`的前序遍历，对应二叉树的前序遍历。
+ `树`的后序遍历，对应二叉树的中序遍历。
+ `树`的从下向上的层次遍历，对应二叉树的后序遍历。
+ `森林`的前序遍历，对应二叉树的前序遍历。
+ `森林`的中序遍历，对应二叉树的中序遍历。

## 11. 下面的哪个序列可能是二叉搜索树中序遍历的结果?

+ 73 8 2 9 4 11  (A)
+ 2 3 4 7 8 9 11  (B)
+ 11 2 9 3 8 4 7  (C)
+ 以上均可 (D)

`答案：` B

+ 二叉搜索树中序遍历的结果一定是从小到大的有序序列，只可能是B
+ 二叉搜索树一个很重要的特性就是：树中任何结点的左子树中所有结点的值均比该结点小，右子树中所有结点的值均比该结点大。对二叉搜索树进行中序遍历即得到一个递增排序的序列。

## 12. 设森林F中有三棵树，第一，第二，第三棵树的结点个数分别为M1，M2和M3。与森林F对应的二叉树根结点的右子树上的结点个数是( )。

`答案：` M3

+ 森林转换为二叉树： 
  + 1.将森林中每棵树转换为相应的二叉树
  + 2.第一颗二叉树不动，依次吧后一棵二叉树的跟节点作为前一颗二叉树根节点的右孩子，当所有二叉树链在一起后，所得的二叉树就是森林对应的二叉树

![](https://uploadfiles.nowcoder.com/images/20180222/1042593_1519286110490_F753C3A75140EF4445B7E6826161C842)

## 13. 已知一棵有2011个结点的树,其叶结点个数为116，该树对应的二叉树无右孩子的结点个数为

`答案：` 1896

> 转换出来的二叉树中，一共有2011*2个链域，其中左右链域各2011个。设非空的左链域有XL个，非空的右链域有XR个，那么XL+XR+1=2011（总节点数为根节点加左右孩子数）
且因为二叉树是由树转化而来，因此节点在树中至少要有一个孩子才能在转化为二叉树后有左孩子（也就是非叶节点），也就是说有2011-116个节点在二叉树中有左孩子，因此XL=2011-116，代入上式可得2011-116+XR+1=2011，因此XR=115。
由此， 空的右链域=2011(右链域数)-XR=1896个，得解

## 14. 下列关于m阶B-树的说法错误的是()

+ 根结点至多有m棵子树
+ 所有叶子都在同一层次上
+ 非叶结点至少有m/2(m为偶数)或m/2+1(m为奇数)棵子树（√）
+ 根结点中的数据是有序的

![image.png](https://upload-images.jianshu.io/upload_images/9140378-04e1163e3851a6a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)

## 15.一棵有124个叶结点的完全二叉树，最多有（ ）个结点

`答案：` 148

> 思路：节点数=分支数+1
设度为1的节点n1个，度为2的节点为n2个，题设知道度为0的节点有124
124+n1+n2=n1+2*n2+1  n2=123   
完全二叉树中，度为1的节点只能是1或者0个，此处取1
所以总共最多248个节点

## 16. 若连通网络的各边的权值均不相同，则依据Prim算法所构造的最小生成树是唯一的()。 

`答案：`错误

+ 造成最小生成树不唯一原因是：有权值相同的边，但题目明确边权值不同，所以就得到唯一最小生成树

## 17. 不同的求最小生成树的方法最后得到的生成树是相同的()

`答案：`错误

+ 可以有不同的， 只要权值是最小值就可以了。  

## 18. 连通分量指的是 无 向图中的极大连通子图。

`答案：`正确

+ 极大连通子图——无向图
+ 极大强连通子图——有向图

## 19.有ABCDEF 六个城市，每一个城市都和其他所有城市直接相连，问从A——B有多少种连接方式，路径不允许在两个城市之间往返

`答案：`65

+ A - B : 1
+ A - ? - B : 4
+ A -  ? - ? - B : 4 * 3
+ A - ? - ? - ? - B : 4 * 3 * 2
+ A - ? - ? - ? - ? - B : 4 * 3 * 2 * 1

## 20. 求最短路径的FLOYD算法的时间复杂度为（）。

`答案：`O(n^3)

+ Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。


### 21. 如果使用比较高效的算法判断单链表有没有环的算法中，至少需要几个指针？

+ 判断链表有没有环，可以用快慢指针来实现，两指针的移动速度不一样。如果相遇，则表示有环，否则表示无环

### 22. 若用一个大小为6的数组来实现循环队列，队尾指针是rear、队头是front。当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为

+ 删除操作户front=(front++)%n;插入操作rear=(rear++)%n，计算即可

### 23. 最大容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是（）

循环队列的相关条件和公式：

+ 1.队空条件：rear==front
+ 2.队满条件：(rear+1) %QueueSIze==front，其中QueueSize为循环队列的最大长度
+ 3.计算队列长度：（rear-front+QueueSize）%QueueSize
+ 4.入队：（rear+1）%QueueSize
+ 5.出队：（front+1）%QueueSize

### 24. 一个非空广义表的表尾()

+ （1）《数据结构》对广义表的表头和表尾是这样定义的： 如果广义表LS=（a1,a2...an）非空，则 a1是LS的表头，其余元素组成的表（a2,a3,..an）是称为LS的表尾。  
+ 根据定义，非空广义表的 表头是一个元素，它 可以是原子也可以是一个子表， 而表尾则必定是子表。例如:LS=(a,b),表头为a,表尾是（b）而不是b.另外：LS=（a)的表头为a，表尾为空表().
+ （2）非空广义表，除表头外，其余元素构成的表称为表尾，所以非空广义表尾一定是个表